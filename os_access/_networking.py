# Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/
import logging
import socket
import time
from abc import ABCMeta
from abc import abstractmethod
from functools import lru_cache
from ipaddress import IPv4Address
from ipaddress import IPv4Interface
from ipaddress import IPv4Network
from typing import Collection
from typing import Tuple

from vm.hypervisor import PciAddress

_logger = logging.getLogger(__name__)


class InterfaceDown(Exception):
    pass


@lru_cache()
def get_host_by_name(hostname):
    for _ in range(3):
        try:
            return socket.gethostbyname(hostname)
        except socket.gaierror:
            _logger.debug("Failed to get ip by name {}".format(hostname))
            time.sleep(1)
    return socket.gethostbyname(hostname)


def current_host_address() -> str:
    """Find address in the network with test machines.

    Find address facing 10.0.0.0 subnet by fake UDP socket connect.
    A common setup is Internet plus VPN (10.0.0.0),
    which fails if 8.8.8.8 is used to connect to.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
        s.connect(("10.0.0.1", 80))
        return s.getsockname()[0]


class Networking(metaclass=ABCMeta):

    @abstractmethod
    def get_ip_addresses(self) -> Collection[IPv4Interface]:
        pass

    def get_ip_addresses_within_subnet(self, subnet: IPv4Network) -> Collection[IPv4Interface]:
        ip_addresses = self.get_ip_addresses()
        return [ip for ip in ip_addresses if ip in subnet]

    @abstractmethod
    def _link_is_up(self, nic_id: PciAddress) -> bool:
        pass

    def wait_for_link(self, nic_id: PciAddress):
        nic_name = self.get_interface_name(nic_id)
        started_at = time.monotonic()
        # There seems to be some strange behavior on Ubuntu:
        # - when traffic capture is not started, waiting for the link to come up can take up to 30 seconds;
        # - when traffic capture is started, the link comes up fast, typically up to 6-7 seconds;
        # - An error similar to 'ata1.00: exception Emask 0x0 SAct 0x30000 SErr 0x0 action 0x6 frozen'
        #   might have caused the VM to freeze for a duration of 25-30 seconds. This occurrence
        #   could be purely coincidental, but it has been observed that this error only appears
        #   after executing the 'ip link up' command on the Chrome VM. There have been discussions
        #   on various forums without reaching a definitive solution, and a ticket has been opened
        #   on VirtualBox.org to address this issue.
        #   See: https://www.virtualbox.org/ticket/20294
        timeout_sec = 40
        while not self._link_is_up(nic_id):
            if time.monotonic() - started_at > timeout_sec:
                raise InterfaceDown(f"Interface {nic_name} is down after {timeout_sec} seconds")
            time.sleep(1)
        _logger.info(
            'The network interface %s is up after %.2f seconds',
            nic_name, time.monotonic() - started_at)

    @abstractmethod
    def setup_static_ip(self, nic_id: PciAddress, *ip_list: IPv4Interface):
        pass

    @abstractmethod
    def set_route(self, destination_ip_net, gateway_bound_nic_id: PciAddress, gateway_ip):
        pass

    @abstractmethod
    def disable_internet(self):
        pass

    @abstractmethod
    def allow_subnet(self, network):
        pass

    @abstractmethod
    def _block_subnet(self, network):
        pass

    def allow_multicast(self):
        self.allow_subnet('224.0.0.0/3')

    def block_multicast(self):
        self._block_subnet('224.0.0.0/3')

    @staticmethod
    def _exclude_broadcast(network: IPv4Network) -> Tuple[IPv4Address, IPv4Address]:
        return network.network_address, network.broadcast_address - 1

    @abstractmethod
    def _allow_ip_range(self, first_ip, last_ip):
        pass

    def allow_subnet_unicast(self, network):
        network = IPv4Network(network)
        # Replacing a network with a range with excluded broadcast address helps to suppress
        # unwanted network broadcast traffic, generated by OS.
        [first_ip, last_ip] = self._exclude_broadcast(network)
        return self._allow_ip_range(first_ip, last_ip)

    @abstractmethod
    def _allow_host(self, ip_addr: IPv4Address):
        pass

    @abstractmethod
    def _block_host(self, ip_addr: IPv4Address):
        pass

    def allow_hosts(self, hosts):
        for host in hosts:
            ip_addr = get_host_by_name(host)
            self._allow_host(IPv4Address(ip_addr))

    def block_hosts(self, hosts):
        for host in hosts:
            ip_addr = get_host_by_name(host)
            self._block_host(IPv4Address(ip_addr))

    @abstractmethod
    def allow_destination(self, network, protocol, port):
        pass

    @abstractmethod
    def block_destination(self, network, protocol, port):
        pass

    def allow_subnet_broadcast(self, network):
        network = IPv4Network(network)
        return self._allow_host(network.broadcast_address)

    def block_subnet_broadcast(self, network):
        network = IPv4Network(network)
        return self._block_host(network.broadcast_address)

    @abstractmethod
    def setup_nat(self, nic_id: PciAddress):
        pass

    @abstractmethod
    def ping(self, ip: str, timeout_sec=30):
        pass

    @abstractmethod
    def _set_interface_state(self, nic_id: PciAddress, enabled: bool):
        pass

    @abstractmethod
    def get_interface_name(self, nic_id: PciAddress):
        pass

    @abstractmethod
    def get_interface_stats(self, nic_id: PciAddress):
        pass

    @abstractmethod
    def disable_outbound_non_unicast(self):
        pass

    def disable_interface(self, nic_id: PciAddress):
        return self._set_interface_state(nic_id, enabled=False)

    def enable_interface(self, nic_id: PciAddress):
        return self._set_interface_state(nic_id, enabled=True)

    @abstractmethod
    def _get_default_gateway_address(self) -> IPv4Address:
        pass

    def get_internal_addresses(self) -> Collection[str]:
        return {
            str(interface.ip) for interface in self.get_ip_addresses()
            if self._get_default_gateway_address() not in interface.network}


class PingError(Exception):

    def __init__(self, error, destination_address):
        super().__init__(f"Ping to {destination_address} failed. Error: {error}")
