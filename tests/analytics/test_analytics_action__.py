# Copyright 2018-present Network Optix, Inc. Licensed under MPL 2.0: www.mozilla.org/MPL/2.0/
from contextlib import ExitStack
from enum import Enum
from typing import Any
from typing import List
from typing import Mapping
from typing import MutableMapping
from typing import Optional
from uuid import UUID

from tests.analytics.common import prepare_one_mediaserver_stand
from tests.analytics.common import record_analytics_tracks
from tests.analytics.common import recording_camera


def _test_analytics_action(
        distrib_url: str,
        vm_type: str,
        api_version: str,
        exit_stack: ExitStack,
        with_plugins_from_release: Optional[str] = None,
        ):
    stand = prepare_one_mediaserver_stand(
        distrib_url, vm_type, api_version, exit_stack, with_plugins_from_release)
    mediaserver = stand.mediaserver()
    camera_id = exit_stack.enter_context(recording_camera(mediaserver)).id
    engine_collection = mediaserver.api.get_analytics_engine_collection()
    engine = engine_collection.get_stub('Object Actions')
    mediaserver.api.enable_device_agent(engine, camera_id)
    record_analytics_tracks(mediaserver.api)
    [track, *_] = mediaserver.api.list_analytics_objects_tracks()
    action_timestamp = track.time_period().start_ms
    message_action_result = mediaserver.api.execute_analytics_action(
        engine_id=engine.id(),
        action_id=_StubActionIds.message.value,
        object_track_id=track.track_id(),
        camera_id=camera_id,
        timestamp=action_timestamp,
        )
    assert message_action_result['actionUrl'] == ''
    message_action_msg = _CommonMessage.from_raw(message_action_result['messageToUser'])
    assert track.track_id() == message_action_msg.track_id()
    assert action_timestamp == message_action_msg.timestamp()
    assert camera_id == message_action_msg.device_id()
    url_action_result = mediaserver.api.execute_analytics_action(
        engine_id=engine.id(),
        action_id=_StubActionIds.url.value,
        object_track_id=track.track_id(),
        camera_id=camera_id,
        timestamp=action_timestamp,
        )
    assert url_action_result['actionUrl'] == 'https://example.com'
    assert url_action_result['messageToUser'] == ''
    params = {'testTextField': 'Test value!'}
    params_action_result = mediaserver.api.execute_analytics_action(
        engine_id=engine.id(),
        action_id=_StubActionIds.params.value,
        object_track_id=track.track_id(),
        camera_id=camera_id,
        timestamp=action_timestamp,
        params=params,
        )
    assert params_action_result['actionUrl'] == ''
    params_action_msg = _MessageWithParams.from_raw(params_action_result['messageToUser'])
    assert track.track_id() == params_action_msg.track_id()
    assert action_timestamp == params_action_msg.timestamp()
    assert camera_id == params_action_msg.device_id()
    assert params == params_action_msg.params()
    requirements_action_result = mediaserver.api.execute_analytics_action(
        engine_id=engine.id(),
        action_id=_StubActionIds.requirements.value,
        object_track_id=track.track_id(),
        camera_id=camera_id,
        timestamp=action_timestamp,
        )
    assert requirements_action_result['actionUrl'] == ''
    requirements_action_msg = _MessageWithRequirements.from_raw(
        requirements_action_result['messageToUser'])
    assert track.track_id() == requirements_action_msg.track_id()
    assert action_timestamp == requirements_action_msg.timestamp()
    assert camera_id == requirements_action_msg.device_id()
    assert requirements_action_msg.object_track_info()['Best shot frame'] != 'null'
    assert requirements_action_msg.object_track_info()['Best shot metadata'] != 'null'


class _StubActionIds(Enum):
    message = 'nx.stub.objectActionWithMessageResult'
    url = 'nx.stub.objectActionWithUrlResult'
    params = 'nx.stub.objectActionWithParameters'
    requirements = 'nx.stub.objectActionWithRequirements'


class _CommonMessage:
    r"""Stub, Object Actions: Process common messageToUser from /api/executeAnalyticsAction reply.

    >>> message_to_user = (
    ...     "Message generated by the Plugin:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us")
    >>> action_message = _CommonMessage.from_raw(message_to_user)
    >>> assert action_message.track_id() == UUID('{9D5B299A-DE9B-4D2B-B027-F294C1330100}')
    >>> assert action_message.device_id() == UUID('{99C0C483-013E-6B21-2347-F03B784B573A}')
    >>> action_message.timestamp()
    1704389815900

    >>> message_to_user = (
    ...     "Message generated by the Unknown Text:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us")
    >>> action_message = _CommonMessage.from_raw(message_to_user) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    RuntimeError: Unable to parse message:
    ...

    >>> message_to_user = (
    ...     "Message generated by the Integration:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us")
    >>> action_message = _CommonMessage.from_raw(message_to_user)
    >>> assert action_message.track_id() == UUID('{9D5B299A-DE9B-4D2B-B027-F294C1330100}')
    >>> assert action_message.device_id() == UUID('{99C0C483-013E-6B21-2347-F03B784B573A}')
    >>> action_message.timestamp()
    1704389815900
    """

    def __init__(self, raw: Mapping):
        self._raw = raw

    def track_id(self) -> UUID:
        return UUID(self._raw['Track id'])

    def device_id(self) -> UUID:
        return UUID(self._raw['Device id'])

    def timestamp(self) -> int:
        timestamp_us = int(self._raw['Timestamp'].rstrip(' us'))
        return timestamp_us // 1000

    @classmethod
    def from_raw(cls, message: str):
        parsed = _parse_indented_text(message)
        data = parsed.get('Message generated by the Plugin')
        if data is None:
            data = parsed.get('Message generated by the Integration')
        if data is None:
            raise RuntimeError(f'Unable to parse message: {parsed}')
        return cls(data)


class _MessageWithParams(_CommonMessage):
    r"""Stub, Object Actions: Process messageToUser with additional parameters.

    >>> message_to_user = (
    ...     "Message generated by the Plugin:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us,\n"
    ...     "    Parameters:\n"
    ...     "        testTextField: [Test value!]")
    >>> action_message = _MessageWithParams.from_raw(message_to_user)
    >>> action_message.params()
    {'testTextField': 'Test value!'}
    """

    def params(self) -> Mapping[str, str]:
        raw_params = self._raw['Parameters']
        # Stub encloses parameter values in brackets to mark their start/end.
        return {k: v.strip('[]') for k, v in raw_params.items()}


class _MessageWithRequirements(_CommonMessage):
    r"""Stub, Object Actions: Process messageToUser with requirements.

    >>> message = (
    ...     "Message generated by the Plugin:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us,\n"
    ...     "    Object Track Info:\n"
    ...     "        Best shot frame: 640x320 yuv420\n"
    ...     "        Best shot metadata: Timestamp: 1704983031194000 us")
    >>> action_message = _MessageWithRequirements.from_raw(message)
    >>> action_message.object_track_info()
    {'Best shot frame': '640x320 yuv420', 'Best shot metadata': 'Timestamp: 1704983031194000 us'}
    """

    def object_track_info(self):
        return self._raw['Object Track Info']


def _parse_indented_text(text: str) -> Mapping[str, str]:
    r"""Stub, Object Actions: Convert indent-formatted user message string into a mapping.

    >>> message = (
    ...     "Message generated by the Plugin:\n"
    ...     "    Track id: {9D5B299A-DE9B-4D2B-B027-F294C1330100},\n"
    ...     "    Device id: {99C0C483-013E-6B21-2347-F03B784B573A},\n"
    ...     "    Timestamp: 1704389815900000 us,\n"
    ...     "    Object Track Info:\n"
    ...     "        Best shot frame: 640x320 yuv420\n"
    ...     "        Best shot metadata: Timestamp: 1704983031194000 us,\n"
    ...     "    Parameters:\n"
    ...     "        testTextField: [Test value!]")
    >>> expected = {
    ...     'Message generated by the Plugin': {
    ...          'Track id': '{9D5B299A-DE9B-4D2B-B027-F294C1330100}',
    ...          'Device id': '{99C0C483-013E-6B21-2347-F03B784B573A}',
    ...          'Timestamp': '1704389815900000 us',
    ...          'Object Track Info': {
    ...              'Best shot frame': '640x320 yuv420',
    ...              'Best shot metadata': 'Timestamp: 1704983031194000 us',
    ...              },
    ...          'Parameters': {'testTextField': '[Test value!]'},
    ...          }}
    >>> actual = _parse_indented_text(message)
    >>> assert actual == expected
    """
    result = {}
    tree = _Tree(result)
    indent_length = 4
    for line in text.splitlines():
        line_level = (len(line) - len(line.lstrip())) // indent_length
        while tree.node_deeper(line_level):
            tree.step_back()
        if line.endswith(':'):
            key = line.lstrip().rstrip(':')
            tree.push_node(key)
            continue
        key, value = line.strip().split(':', maxsplit=1)
        tree.set_keypair(key, value.strip().rstrip(','))
    return result


class _Tree:

    def __init__(self, root: MutableMapping[str, Any]):
        self._root = root
        self._stack: List[MutableMapping[str, Any]] = []

    def node_deeper(self, level: int) -> bool:
        return len(self._stack) > level

    def step_back(self):
        self._stack.pop()

    def set_keypair(self, key: str, value: str):
        self._top()[key] = value

    def push_node(self, key: str):
        new_current_node = {}
        self._top()[key] = new_current_node
        self._stack.append(new_current_node)

    def _top(self) -> MutableMapping[str, Any]:
        try:
            return self._stack[-1]
        except IndexError:
            return self._root
